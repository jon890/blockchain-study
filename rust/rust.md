# Rust 공부

- https://docs.microsoft.com/ko-kr/learn/paths/rust-first-steps

## Rust로 첫 번째 단계 수행
1. Rust 코드의 첫 줄을 작성하는데 필요한 도구 설치
2. Rust 기본 개념 공부
3. 오류 처리법 공부
4. Rust에서 메모리 관리
5. 제네릭 형식 및 특성 사용
6. 패키지 및 크레이트에 대한 모듈 설정
7. 자동화 테스트를 쓰고 실행
8. 명령줄 프로그램 만들기

### Rust란 무엇인가?
- 효율적이고 안전한 소프트웨어를 개발하는 데 사용할 수 있는 오픈 소스 시스템 프로그래밍 언어
- 메모리를 관리하고 기타 하위 수준 세부 정보를 제어 가능

- 광범위한 애플리케이션에 적합한 이점이 있음
    1. 형식 안전 : 컴파일러는 잘못된 형식의 변수에 어떤 작업도 적용되지 않게 보장
    2. 메모리 안전 : Rust 포인터는 항상 유효한 메모리를 참조
    3. 데이터 경합 없음 : 바로우 검사기(?)는 프로그램의 여러 부분이 동일한 값을 동시에 변경할 수 없도록 하여 스레드 안전 보장
    4. 무비용 추출 : 최소한의 성능 비용으로, 또는 성능 비용 없이 반복, 인터페이스, 함수 프로그래밍 같은 상위 수준의 개념 사용할 수 있음, 또한 추상화는 기본 코드를 직접 작성하는 것처럼 수행
    5. 운영 체제 미설치 대상 : 임베디드 및 "운영 체제 미설치" 프로그래밍을 대상으로 지정하여 운영 체제 커널 또는 디바이스 드라이버 작성에 적합하도록 한다

- 2021년 Stack Overflow 개발자 설문 조사에서 가장 인기있는 언어! https://insights.stackoverflow.com/survey

### Rust의 고유한 기능
- 프로그래밍 언어가 프로젝트에 적합한지 확인하려면, 기능 및 제한 사항에 대해 알아야 함

- Rust의 기능 제한 사항
    1. Rust 모듈 시스템 : 모듈, 크레이트, 경로
    2. Rust 표준 라이브러리 및 타사 크레이트
    3. Rust Cargo 도구 및 종속성 관리자
    4. Rust는 언제 사용하면 좋을까?

#### Rust 모듈 시스템을 사용한 코드 관리
- Rust 모듈 시스템 : 코드를 관리하고 구성하는데 도움이 되는 기능 모음

- 크레이트 : 컴파일 단위. Rust 컴파일러에서 실행할 수 있는 가장 작읍 코드 부분. 크레이트에 있는 코드는 이진 실행 파일이나 라이브러리를 생성하기 위해 함께 컴파일. Rust에서는 크레이트 만이 다시 사용할 수 있는 단위로 컴파일 된다. 크레이트는 명명되지 않은 암시적 최상위 모듈이 이쓴ㄴ Rust 모듈의 계층 구조를 포함한다.

- 모듈 : 크레이트 내에서 개별 코드 항목의 범위를 관리하도록 하여 프로그램을 구성하는 데 도움이 된다. 관련 코드 항모 또는 함께 사용되는 항목을 동일한 모듈로 그릅화 할 수 있다. 순환 코드 정의는 다른 모듈에 걸쳐 있을 수 있다.

- 경로 : 코드의 이름 항목을 지정할 수 있다. 예를 들어, 경로는 벡터, 코드 함수, 모듈 등의 데이터 정의가 될 수 있다. 모듈 기능을 사용하면 경로에 대한 개인 정보를 제어할 수도 있다. 공개적으로 액세스할 수 있는 코드 부분 및 전용 파트를 지정할 수 있다. 이 기능을 통해 구현 세부 정보를 숨길 수 있다.

#### Rust 크레이트 및 라이브러리 사용
- std : Rust의 표준 라이브러리. Rust 프로그램의 기본 정의 및 작업에 사용할 수 있는 코드 포함. String 및 Vec&lt;T&gt;와 같은 핵심 데이터 형식, Rust 기본 형식에 대한 작업, 일반적으로 사용되는 매크로 함수를 위한 코드, 입력 및 출력 작업에 대한지원, 기타 여러 기능 영역이 포함되어 있음.

- Rust에는 수만 개의 라이브러리와 타사 크레이트를 사용할 수 있다. 대부분의 경우 Rust 타사 크레이트 리포지토리인 https://crates.io 를 통해 액세스 할 수 있다.

- 몇 가지 크레이트를 살펴보자.
    - std : Rust 표준 라이브러리.
        - std::collections : HashMap 등의 컬렉션 형식에 대한 정의
        - std::env : 사용자 환경으로 작업하기 위한 함수
        - std::fmt : 출력 형식을 제어하는 기능
        - std::fs : 파일 시스템을 사용하기 위한 함수
        - std::io : 입/출력 작업을 위한 정의 및 기능
        - std::path : 파일 시스템 경로 데이터 작업을 지원하는 정의 및 함수
    - structopt : 명령줄 인수를 쉽게 구문 분석하기 위한 타사 크레이트
    - chrono : 날짜 및 시간 데이터를 처리하는 타사 크레이트
    - regex : 정규식을 사용하는 타사 크레이트
    - serde : Rust 데이터 구조에 대한 Serialization 및 Deserialization 작업의 타사 크레이트

- 기본적으로 std 라이브러리는 모든 Rust에서 사용 가능
- 크레이트 또는 라이브러리에서 재사용 가능한 코드에 액세스 하기 위해 use 키워드를 구현
- use 키워드를 사용하는 경우에는 프로그램의 정의 및 함수에 액세스할 수 있도록 크레이트 또는 라이브러리의 코드가 "범위로 전환"된다.
- 표준 라이브러리는 use std::fmt 에서와 같이 std 경로를 사용하여 use 문에서 액세스 할 수 있다.
- 다른 크레이트나 라이브러리에는 use regex::Regex 과 같이 이름을 사용하여 액세스한다.

#### Cargo를 사용하여 프로젝트 생성 및 관리
- Rust 컴파일러(rustc)를 사용하여 크레이트를 직접만들 수 있지만 대부분의 프로젝트는 Rust 빌드 도구와 Cargo 라는 종속성 관리자를 사용한다

- Cargo 명령어
    - cargo new : 새 프로젝트 템플릿 생성
    - cargo build : 프로젝트 빌드
    - cargo run : 프로젝트 빌드 실행
    - cargo test : 프로젝트 테스트
    - cargo check : 프로젝트 유형을 확인
    - cargo doc : 프로젝트 설명서 작성
    - cargo publish : crates.io에 라이브러리 게시

- 크레이트 이름을 Cargo.toml 파일에 추가하여 프로젝트에 종속 파일을 추가한다

#### Rust는 언제 사용하면 좋을까?

- C 및 C++와 같은 언어로 작성된 프로그램 및 라이브러리의 성능 및 리소스 사용을 제어하면서, 메모리 안전 상태에서 일반적인 버그의 전체 클래스를 제거할 수 있다.
- 개발자가 규칙 또는 설명서에 의존하지 않고 프로그램의 다양한 고정 요소를 컴파일러가 확인하는 코드로 인코딩 할 수 있는 다양한 추상화 기능이 있다. 이 기능으로 인해 "컴파일하면 작동한다"라는 느낌을 받을 수 있다.
- 코드를 빌드, 테스트, 문서화 및 공유하기 위한 기본 제공 도구와 타사 도구 및 라이브러리의 풍부한 에코시스템이 포함되어있다.
